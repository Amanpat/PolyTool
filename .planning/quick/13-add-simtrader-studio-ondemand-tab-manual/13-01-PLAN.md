---
phase: 13-add-simtrader-studio-ondemand-tab-manual
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/polymarket/simtrader/orderbook/l2book.py
  - packages/polymarket/simtrader/studio/ondemand.py
  - packages/polymarket/simtrader/studio/app.py
autonomous: true
must_haves:
  truths:
    - "L2Book exposes top_bids(n) and top_asks(n) returning sorted price/size lists"
    - "OnDemandSession loads tape events into memory and advances cursor on step()"
    - "POST /api/ondemand/new creates a session and returns session_id + initial state"
    - "POST /api/ondemand/{id}/step advances the tape and returns updated state"
    - "POST /api/ondemand/{id}/order submits a limit order and returns order_id + state"
    - "POST /api/ondemand/{id}/cancel cancels an order and returns updated state"
    - "POST /api/ondemand/{id}/save writes 6 artifact files under ondemand_sessions/<id>/"
  artifacts:
    - path: "packages/polymarket/simtrader/orderbook/l2book.py"
      provides: "top_bids/top_asks methods"
      contains: "def top_bids"
    - path: "packages/polymarket/simtrader/studio/ondemand.py"
      provides: "OnDemandSession class + session manager"
      exports: ["OnDemandSession", "OnDemandSessionManager"]
    - path: "packages/polymarket/simtrader/studio/app.py"
      provides: "8 new /api/ondemand/* routes"
      contains: "/api/ondemand"
  key_links:
    - from: "studio/app.py /api/ondemand routes"
      to: "studio/ondemand.py OnDemandSessionManager"
      via: "app.state.ondemand_sessions"
      pattern: "app\\.state\\.ondemand"
    - from: "ondemand.py OnDemandSession.step()"
      to: "sim_broker.py SimBroker.step()"
      via: "self._broker.step(event, book)"
      pattern: "self\\._broker\\.step"
    - from: "ondemand.py get_state()"
      to: "l2book.py top_bids/top_asks"
      via: "self._book.top_bids(5)"
      pattern: "top_bids"
---

<objective>
Implement the OnDemand engine backend: L2Book depth methods, OnDemandSession class, and FastAPI routes.

Purpose: Provides the deterministic tape-playback engine and REST API that the OnDemand UI tab calls. Reuses SimBroker, L2Book, and PortfolioLedger exactly as-is.
Output: l2book.py with top_bids/top_asks, studio/ondemand.py, app.py with 8 new routes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@packages/polymarket/simtrader/orderbook/l2book.py
@packages/polymarket/simtrader/broker/sim_broker.py
@packages/polymarket/simtrader/broker/rules.py
@packages/polymarket/simtrader/portfolio/ledger.py
@packages/polymarket/simtrader/tape/schema.py
@packages/polymarket/simtrader/studio/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add top_bids/top_asks to L2Book</name>
  <files>packages/polymarket/simtrader/orderbook/l2book.py</files>
  <action>
Add two new public methods to the L2Book class immediately after the `best_ask` property:

```python
def top_bids(self, n: int = 5) -> list[dict]:
    """Return top N bid levels sorted by price descending (highest first).

    Each entry: {"price": float, "size": float}
    Returns empty list if book not initialized or bid side is empty.
    """
    if not self._bids:
        return []
    sorted_levels = sorted(
        ((Decimal(p), s) for p, s in self._bids.items()),
        key=lambda x: x[0],
        reverse=True,
    )
    return [{"price": float(p), "size": float(s)} for p, s in sorted_levels[:n]]

def top_asks(self, n: int = 5) -> list[dict]:
    """Return top N ask levels sorted by price ascending (lowest first).

    Each entry: {"price": float, "size": float}
    Returns empty list if book not initialized or ask side is empty.
    """
    if not self._asks:
        return []
    sorted_levels = sorted(
        ((Decimal(p), s) for p, s in self._asks.items()),
        key=lambda x: x[0],
    )
    return [{"price": float(p), "size": float(s)} for p, s in sorted_levels[:n]]
```

No other changes to l2book.py. The Decimal import is already present.
  </action>
  <verify>
python -c "
from packages.polymarket.simtrader.orderbook.l2book import L2Book
b = L2Book('tok1', strict=False)
b.apply({'event_type':'book','bids':[{'price':'0.52','size':'100'},{'price':'0.51','size':'200'},{'price':'0.50','size':'300'}],'asks':[{'price':'0.53','size':'150'},{'price':'0.54','size':'50'}]})
print(b.top_bids(2))  # expect [{price:0.52,...},{price:0.51,...}]
print(b.top_asks(2))  # expect [{price:0.53,...},{price:0.54,...}]
"
  </verify>
  <done>top_bids returns levels in descending price order, top_asks in ascending price order, both truncated to n. Empty lists returned when book has no levels.</done>
</task>

<task type="auto">
  <name>Task 2: Implement OnDemandSession and session manager</name>
  <files>packages/polymarket/simtrader/studio/ondemand.py</files>
  <action>
Create a new file `packages/polymarket/simtrader/studio/ondemand.py` with the following design:

**Imports:** json, uuid, datetime (timezone, UTC), pathlib.Path, decimal.Decimal, typing (Optional, Any), dataclasses (dataclass, field), and the existing SimBroker, L2Book, PortfolioLedger, Side, tape schema constants.

**`OnDemandSession` class:**

`__init__(self, tape_path: str, starting_cash: Decimal, fee_rate_bps: Optional[Decimal] = None, mark_method: str = "bid")`:
- Load all events from `Path(tape_path) / "events.jsonl"` into `self._events: list[dict]` (sorted by seq ascending). Use utf-8 encoding, skip blank lines.
- Detect all unique asset_ids in the events: for each event, check `event.get("asset_id")` and also entries in `event.get("price_changes", [])` for their `asset_id` fields. Collect into `self._asset_ids: list[str]`.
- Create one `L2Book(asset_id, strict=False)` per asset → `self._books: dict[str, L2Book]`.
- Instantiate `self._broker = SimBroker()` (zero latency).
- Store `self._starting_cash = starting_cash`, `self._fee_rate_bps = fee_rate_bps`, `self._mark_method = mark_method`.
- `self._cursor: int = 0` (index into self._events).
- `self._last_trade_price: Optional[float] = None`.
- `self._timeline: list[dict] = []` — for PortfolioLedger.process (book-affecting events: seq, ts_recv, best_bid, best_ask for the primary asset, i.e. first asset_id or None).
- `self._user_actions: list[dict] = []` — wall-clock log of user actions.
- `self._session_id: str = uuid.uuid4().hex[:12]`.
- `self._started_at: str = datetime.now(timezone.utc).isoformat()`.
- `self._tape_path: str = tape_path`.

`step(self, n: int = 1) -> dict`:
- Advance the cursor by n events (or until end of tape).
- For each event advanced:
  - Apply to relevant L2Book(s): if event_type == "book" or "price_change", apply to book whose asset_id matches `event.get("asset_id")`. For modern batched events with `price_changes[]`, apply each entry's delta to the matching book via `book.apply_single_delta(entry)`.
  - Call `self._broker.step(event, primary_book)` where primary_book is `self._books[self._asset_ids[0]]` if asset_ids is non-empty, else create a dummy L2Book. Pass no fill_asset_id filter (simple single-asset use case).
  - If event_type == "last_trade_price", update `self._last_trade_price = event.get("price")` as float.
  - If event is book-affecting (event_type in {book, price_change}), append timeline entry: `{"seq": seq, "ts_recv": ts_recv, "best_bid": primary_book.best_bid, "best_ask": primary_book.best_ask}`.
- Return `self.get_state()`.

`submit_order(self, asset_id: str, side: str, limit_price: Decimal, size: Decimal) -> tuple[str, dict]`:
- Get current seq from last processed event (or 0 if cursor == 0).
- Call `self._broker.submit_order(asset_id, side, limit_price, size, submit_seq=current_seq, submit_ts=current_ts)`.
- Append to user_actions: `{"ts_wall": now_iso, "action": "submit_order", "params": {"asset_id": asset_id, "side": side, "limit_price": str(limit_price), "size": str(size), "order_id": order_id}}`.
- Return `(order_id, self.get_state())`.

`cancel_order(self, order_id: str) -> dict`:
- Call `self._broker.cancel_order(order_id, cancel_seq=current_seq, cancel_ts=current_ts)`.
- Append to user_actions: `{"ts_wall": now_iso, "action": "cancel_order", "params": {"order_id": order_id}}`.
- Return `self.get_state()`.

`get_state(self) -> dict`:
Returns a dict:
```python
{
    "session_id": self._session_id,
    "cursor": self._cursor,
    "total_events": len(self._events),
    "done": self._cursor >= len(self._events),
    "seq": current_event["seq"] if cursor > 0 else None,
    "ts_recv": current_event["ts_recv"] if cursor > 0 else None,
    "bbo": {
        asset_id: {"best_bid": book.best_bid, "best_ask": book.best_ask}
        for asset_id, book in self._books.items()
    },
    "depth": {
        asset_id: {"bids": book.top_bids(5), "asks": book.top_asks(5)}
        for asset_id, book in self._books.items()
    },
    "last_trade_price": self._last_trade_price,
    "open_orders": [
        {
            "order_id": o.order_id,
            "asset_id": o.asset_id,
            "side": o.side,
            "limit_price": str(o.limit_price),
            "size": str(o.size),
            "filled_size": str(o.filled_size),
            "status": o.status,
        }
        for o in self._broker._orders.values()
        if not o.status.is_terminal()  # use OrderStatus.is_terminal(o.status)
    ],
    "portfolio_snapshot": self._portfolio_snapshot(),
}
```

`_portfolio_snapshot(self) -> dict`:
Quick inline snapshot using PortfolioLedger:
- Instantiate a fresh PortfolioLedger with self._starting_cash, self._fee_rate_bps, self._mark_method.
- Call `.process(self._broker.order_events, self._timeline)`.
- Primary book best_bid/best_ask for summary.
- Call `.summary("live", primary_best_bid, primary_best_ask)`.
- Return the summary dict. (Note: this is O(events) per call but acceptable for a manual session.)

`save_artifacts(self, session_dir: Path) -> None`:
- `session_dir.mkdir(parents=True, exist_ok=True)`.
- Write `user_actions.jsonl`: one JSON line per entry in self._user_actions.
- Get final ledger: fresh PortfolioLedger().process(broker.order_events, timeline) → (ledger_rows, equity_curve).
- Write `ledger.jsonl`: one JSON line per ledger_row.
- Write `equity_curve.jsonl`: one JSON line per equity_curve row.
- Write `orders.jsonl`: one JSON line per event in broker.order_events.
- Write `fills.jsonl`: one JSON line per fill in broker.fills (convert Decimal fields to str via fill._asdict() or manual extraction: fill.order_id, fill.asset_id, fill.side, str(fill.fill_price), str(fill.fill_size), str(fill.remaining), fill.fill_status, fill.because, fill.seq, fill.ts_recv).
- Write `run_manifest.json`: `{"session_id": ..., "tape_path": ..., "started_at": ..., "ended_at": now_iso, "total_events": ..., "cursor": ..., "summary": summary_dict}`.

**`OnDemandSessionManager` class:**
- `__init__(self)`: `self._sessions: dict[str, OnDemandSession] = {}`.
- `create(self, tape_path, starting_cash, fee_rate_bps, mark_method) -> OnDemandSession`: instantiates, stores by session_id, returns session.
- `get(self, session_id) -> OnDemandSession`: returns session or raises KeyError.
- `delete(self, session_id) -> None`: pops from dict (no error if missing).

Use `from __future__ import annotations` at top. All Decimal conversions from string at API boundary (done in Task 3). Keep this module import-safe (no side effects at module level).
  </action>
  <verify>
python -c "
import sys; sys.path.insert(0, '.')
from packages.polymarket.simtrader.studio.ondemand import OnDemandSession, OnDemandSessionManager
print('imports OK')
mgr = OnDemandSessionManager()
print('manager OK')
"
  </verify>
  <done>Module imports without error. OnDemandSession and OnDemandSessionManager are importable. The class correctly wires SimBroker, L2Book (with top_bids/top_asks), and PortfolioLedger without adding new fill logic.</done>
</task>

<task type="auto">
  <name>Task 3: Add OnDemand API routes to app.py</name>
  <files>packages/polymarket/simtrader/studio/app.py</files>
  <action>
Add 8 new routes to `create_app()` in `app.py`. Insert immediately after the existing `POST /api/run` route, before the final `return app`.

First, add to the top-level imports (after existing imports):
```python
import uuid
from decimal import Decimal, InvalidOperation
```

Add the session manager initialization at the start of `create_app()`, after `_artifacts_dir = artifacts_dir`:
```python
from .ondemand import OnDemandSessionManager  # local import to avoid circular
_sessions = OnDemandSessionManager()
```

Then add all 8 routes inside `create_app()`:

**POST /api/ondemand/new**
Body: `{tape_path: str, starting_cash: str, fee_rate_bps: str | None, mark_method: str}`.
- Validate tape_path: must be a directory containing events.jsonl. Raise 400 if not.
- Parse starting_cash as Decimal (raise 400 on InvalidOperation).
- Parse fee_rate_bps as Decimal if provided and non-empty, else None.
- mark_method defaults to "bid" if not provided; must be "bid" or "midpoint".
- Call `session = _sessions.create(tape_path, starting_cash, fee_rate_bps, mark_method)`.
- Return `{"session_id": session._session_id, "state": session.get_state()}`.

**POST /api/ondemand/{session_id}/step**
Body: `{n_steps: int = 1}`.
- Get session (raise 404 if missing).
- n_steps clamped to 1-1000.
- Return `{"state": session.step(n_steps)}`.

**POST /api/ondemand/{session_id}/play**
Body: `{n_steps: int = 50}`.
- Same as step but default 50, clamp 1-500.
- Return `{"state": session.step(n_steps)}`.

**POST /api/ondemand/{session_id}/order**
Body: `{asset_id: str, side: str, limit_price: str, size: str}`.
- Get session (raise 404).
- Validate side is "BUY" or "SELL" (raise 400 if not).
- Parse limit_price, size as Decimal (raise 400 on InvalidOperation).
- Validate limit_price in (0, 1] for Polymarket binary markets (raise 400 if outside range).
- Validate size > 0.
- Call `order_id, state = session.submit_order(asset_id, side, limit_price, size)`.
- Return `{"order_id": order_id, "state": state}`.

**POST /api/ondemand/{session_id}/cancel**
Body: `{order_id: str}`.
- Get session (raise 404).
- Call `state = session.cancel_order(order_id)` — wrap in try/except (KeyError → 404, ValueError → 400).
- Return `{"state": state}`.

**GET /api/ondemand/{session_id}/state**
- Get session (raise 404).
- Return `{"state": session.get_state()}`.

**POST /api/ondemand/{session_id}/save**
Body: `{session_dir: str | None}` — optional override for artifact dir.
- Get session (raise 404).
- Default session_dir: `_artifacts_dir / "ondemand_sessions" / session._session_id`.
- Call `session.save_artifacts(Path(session_dir_str))`.
- Return `{"artifact_dir": str(resolved_dir)}`.

**DELETE /api/ondemand/{session_id}**
- Call `_sessions.delete(session_id)` (no error if not found).
- Return `{"deleted": session_id}`.

Error handling pattern for all routes:
```python
session = _get_session(_sessions, session_id)  # helper raises HTTPException(404)
```
Define a module-level helper inside create_app or as a local helper:
```python
def _get_session(mgr, sid):
    try:
        return mgr.get(sid)
    except KeyError:
        raise HTTPException(status_code=404, detail=f"session not found: {sid!r}")
```
  </action>
  <verify>
python -c "
import sys; sys.path.insert(0, '.')
from packages.polymarket.simtrader.studio.app import create_app
import tempfile, pathlib
app = create_app(pathlib.Path(tempfile.mkdtemp()))
routes = [r.path for r in app.routes]
assert any('/api/ondemand/new' in r or 'ondemand' in r for r in routes), f'Missing ondemand routes: {routes}'
print('Routes OK:', [r for r in routes if 'ondemand' in r])
"
  </verify>
  <done>create_app() registers all 8 /api/ondemand/* routes. App imports without error. All existing routes still present.</done>
</task>

</tasks>

<verification>
After all 3 tasks complete:
1. `python -m pytest tests/test_simtrader_arb.py tests/test_simtrader_strategy.py -x -q` — existing tests still pass (no regressions in l2book or broker).
2. `python -c "from packages.polymarket.simtrader.studio.app import create_app; app = create_app(); print('app OK')"` — imports clean.
3. L2Book top_bids/top_asks produce correct sorted output (see Task 1 verify).
</verification>

<success_criteria>
- L2Book.top_bids(n) and top_asks(n) return correct sorted price/size dicts
- OnDemandSession.step() advances cursor, applies books, calls broker.step
- OnDemandSession.get_state() returns bbo/depth/open_orders/portfolio_snapshot
- OnDemandSession.save_artifacts() writes exactly 6 files
- All 8 /api/ondemand/* routes registered and importable
- No regressions in existing simtrader tests
</success_criteria>

<output>
After completion, create `.planning/quick/13-add-simtrader-studio-ondemand-tab-manual/13-01-SUMMARY.md`
</output>
