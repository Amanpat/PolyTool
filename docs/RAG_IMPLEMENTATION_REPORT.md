# RAG Implementation Report

## Trees

### RAG modules

```text
packages/polymarket/rag/
  __init__.py
  chunker.py
  embedder.py
  eval.py
  index.py
  lexical.py
  manifest.py
  metadata.py
  query.py
  reranker.py
```

### CLI entrypoints

```text
polytool/__main__.py            # canonical module entrypoint
tools/cli/rag_index.py
tools/cli/rag_query.py
tools/cli/rag_eval.py
polyttool/__main__.py           # deprecated shim (removal after v0.2.0)
```

## Invocation policy

Canonical usage is:

```bash
python -m polytool rag-index ...
python -m polytool rag-query ...
python -m polytool rag-eval ...
```

`python -m polyttool ...` remains only as a backward-compatibility shim and is
scheduled for removal after `v0.2.0` (or first stable release), per
`docs/adr/ADR-0001-cli-and-module-rename.md`.

## rag-index implementation

### Chunking

Chunking is performed in `chunk_text` and invoked from `build_index`.

```python
# packages/polymarket/rag/chunker.py
def chunk_text(text: str, chunk_size: int = 400, overlap: int = 80) -> List[TextChunk]:
```

```python
# packages/polymarket/rag/index.py
chunks: List[TextChunk] = chunk_text(text, chunk_size=chunk_size, overlap=overlap)
```

### Metadata stored per chunk

Chunk metadata is generated by `build_chunk_metadata` and includes:

- `file_path`, `doc_id`, `chunk_index`, `start_word`, `end_word`, `root`
- `doc_type`, `is_private`
- Optional: `user_slug`, `proxy_wallet`, `created_at`

This metadata is stored in both vector and lexical indexes and is used for
privacy and scope filtering at query time.

### Vector + lexical persistence

Defaults:

- Chroma collection: `polyttool_rag`
- Chroma persist dir: `kb/rag/index`
- Manifest: `kb/rag/manifests/index_manifest.json`
- Lexical DB: `kb/rag/lexical/lexical.sqlite3`

`build_index` writes vectors to Chroma and mirrors the same chunks into SQLite
FTS5 (`chunks` + `chunks_fts`) for lexical retrieval. Rebuild mode clears both.

### IDs

- `doc_id`: deterministic SHA-256 from canonical path + file hash
- `chunk_id`: deterministic SHA-256 from `doc_id` + chunk index + chunk text hash

`chunk_id` is used as the shared key across vector, lexical, fusion, and rerank.

### Reconcile flow

`reconcile_index` compares disk files to both index stores and removes stale
entries from:

- Chroma (`collection.delete(where={"file_path": ...})`)
- Lexical SQLite (`DELETE FROM chunks WHERE file_path = ?`)

## rag-query implementation

### Retrieval modes

`query_index` supports four live modes:

1. `vector`
2. `lexical` (`--lexical-only`)
3. `hybrid` (`--hybrid`)
4. `hybrid+rerank` (`--hybrid --rerank`)

### Lexical retrieval (FTS5)

`lexical_search` performs SQLite FTS5 `MATCH` queries over `chunks_fts`,
sanitizes tokens to avoid operator injection, and applies metadata filters
(`user_slug`, `doc_type`, privacy, date range, archive policy).

### Hybrid fusion (RRF)

Hybrid mode retrieves vector and lexical candidate lists, then fuses them using
Reciprocal Rank Fusion:

```text
rrf_score(c) = sum(1 / (rrf_k + rank_in_list))
```

Default `rrf_k` is `60`.

### Reranker

If `--rerank` is enabled, the fused results are reranked by
`CrossEncoderReranker` (`cross-encoder/ms-marco-MiniLM-L-6-v2` by default).

- Rerank is applied to top `rerank_top_n` candidates (default `50`)
- Output adds `rerank_score` and updates `final_rank`

### Filtering behavior

Primary filtering is metadata-based (`build_chroma_where`) with matching lexical
SQL filters. A path-prefix backstop (`--user` -> user prefixes) is applied
defensively to final candidates.

### CLI output contract

`rag-query` prints JSON payload:

- `question`, `k`, `mode`
- `filters` (`user_slug`, `doc_types`, privacy flags, date bounds, archive flag, prefix backstop)
- `results` (chunk list with snippet + metadata, plus fusion/rerank fields when enabled)

## Repo safety

RAG is intentionally scoped to local-private corpora by default (`kb,artifacts`)
and private-only retrieval defaults are enabled.

Boundary controls:

- `.gitignore`: ignores `artifacts/**`, `kb/**` except `kb/README.md` + `kb/.gitkeep`,
  and RAG index/cache paths under `kb/rag/`
- `tools/guard/pre_push_guard.py`: blocks pushes containing private kb/artifacts paths

